;
; File generated by cc65 v 2.19 - Git c3d7a9008
;
	.fopt		compiler,"cc65 v 2.19 - Git c3d7a9008"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_hardware
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_bright
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_pad_poll
	.import		_pad_state
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_fill
	.import		_vram_unrle
	.import		_set_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_clear_vram_buffer
	.import		_set_scroll_x
	.export		_hardware_vram_erase
	.export		_hardware_ppu_enable
	.export		_hardware_ppu_disable
	.export		_hardware_ppu_write
	.export		_hardware_ppu_scroll_reset
	.export		_hardware_ppu_draw_background
	.export		_hardware_ppu_palette_sprite
	.export		_hardware_ppu_palette_background
	.export		_hardwate_ppu_wait_frame
	.export		_harware_ppu_palette_bright
	.export		_hardware_ppu_blank_screen
	.export		_hardware_ctrl1
	.export		_hardware_ctrl1_prev
	.export		_hardware_ctrl2
	.export		_hardware_ctrl2_prev
	.export		_i
	.export		_j
	.export		_o
	.export		_z
	.export		_index
	.export		_p
	.export		_BG_TITLE
	.export		_PAL_TITLE
	.export		_engine_handleInput
	.export		_engine_detectCollisions
	.export		_engine_detectCollisionWithPlayer
	.export		_engine_start
	.export		_engine_frame_update
	.export		_engine
	.export		_engine_screens
	.export		_engine_actions
	.export		_SPRITES
	.export		_engine_detectCollision
	.export		_BG_INTRO_TITLE
	.export		_PAL_INTRO_TITLE
	.export		_scIntro
	.import		_free
	.export		_scIntroInitialized
	.export		_scIntroDisplayItem
	.export		_scIntroInit
	.export		_scIntroAnimExec
	.export		_main

.segment	"DATA"

_hardware:
	.word	$0000
	.word	$0000
	.word	$0000
	.word	$0000
	.word	$0000
	.res	1,$00
_i:
	.byte	$00
_j:
	.byte	$00
_o:
	.byte	$00
_z:
	.byte	$00
_index:
	.byte	$00
_engine:
	.byte	$00
	.byte	$00
	.addr	S0005
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$00
	.addr	S0006
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$10
	.res	4,$00
_engine_screens:
_engine_actions:
	.res	64,$00
_scIntroInitialized:
	.byte	$00

.segment	"RODATA"

_BG_TITLE:
	.byte	$8B
	.byte	$00
	.byte	$8B
	.byte	$A7
	.byte	$01
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$06
	.byte	$07
	.byte	$08
	.byte	$00
	.byte	$02
	.byte	$09
	.byte	$05
	.byte	$05
	.byte	$03
	.byte	$04
	.byte	$0A
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$0B
	.byte	$0C
	.byte	$0D
	.byte	$00
	.byte	$8B
	.byte	$1C
	.byte	$0E
	.byte	$0F
	.byte	$10
	.byte	$11
	.byte	$00
	.byte	$8B
	.byte	$1B
	.byte	$12
	.byte	$13
	.byte	$14
	.byte	$15
	.byte	$00
	.byte	$8B
	.byte	$02
	.byte	$16
	.byte	$17
	.byte	$18
	.byte	$00
	.byte	$8B
	.byte	$14
	.byte	$19
	.byte	$1A
	.byte	$14
	.byte	$1B
	.byte	$1C
	.byte	$00
	.byte	$00
	.byte	$1D
	.byte	$1E
	.byte	$14
	.byte	$1F
	.byte	$00
	.byte	$8B
	.byte	$14
	.byte	$20
	.byte	$21
	.byte	$22
	.byte	$23
	.byte	$00
	.byte	$8B
	.byte	$02
	.byte	$24
	.byte	$25
	.byte	$26
	.byte	$27
	.byte	$28
	.byte	$00
	.byte	$8B
	.byte	$12
	.byte	$29
	.byte	$2A
	.byte	$2A
	.byte	$2B
	.byte	$00
	.byte	$8B
	.byte	$03
	.byte	$2C
	.byte	$2D
	.byte	$14
	.byte	$2E
	.byte	$2F
	.byte	$00
	.byte	$8B
	.byte	$12
	.byte	$30
	.byte	$2A
	.byte	$8B
	.byte	$02
	.byte	$31
	.byte	$00
	.byte	$00
	.byte	$32
	.byte	$33
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$37
	.byte	$38
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$39
	.byte	$2A
	.byte	$8B
	.byte	$02
	.byte	$3A
	.byte	$00
	.byte	$00
	.byte	$3B
	.byte	$0F
	.byte	$3C
	.byte	$3D
	.byte	$0F
	.byte	$0F
	.byte	$3E
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$3F
	.byte	$2A
	.byte	$8B
	.byte	$02
	.byte	$40
	.byte	$00
	.byte	$00
	.byte	$41
	.byte	$0F
	.byte	$8B
	.byte	$03
	.byte	$42
	.byte	$43
	.byte	$44
	.byte	$00
	.byte	$8B
	.byte	$10
	.byte	$2A
	.byte	$8B
	.byte	$03
	.byte	$45
	.byte	$00
	.byte	$00
	.byte	$46
	.byte	$47
	.byte	$0F
	.byte	$48
	.byte	$49
	.byte	$4A
	.byte	$4B
	.byte	$4C
	.byte	$00
	.byte	$8B
	.byte	$10
	.byte	$4D
	.byte	$2A
	.byte	$8B
	.byte	$02
	.byte	$4E
	.byte	$00
	.byte	$00
	.byte	$4F
	.byte	$50
	.byte	$51
	.byte	$52
	.byte	$53
	.byte	$54
	.byte	$55
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$56
	.byte	$2A
	.byte	$8B
	.byte	$03
	.byte	$57
	.byte	$00
	.byte	$58
	.byte	$59
	.byte	$5A
	.byte	$5B
	.byte	$0F
	.byte	$5C
	.byte	$5D
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$56
	.byte	$2A
	.byte	$5E
	.byte	$5F
	.byte	$2A
	.byte	$60
	.byte	$61
	.byte	$62
	.byte	$63
	.byte	$0F
	.byte	$8B
	.byte	$02
	.byte	$64
	.byte	$65
	.byte	$66
	.byte	$00
	.byte	$8B
	.byte	$10
	.byte	$56
	.byte	$2A
	.byte	$67
	.byte	$68
	.byte	$69
	.byte	$2A
	.byte	$6A
	.byte	$6B
	.byte	$0F
	.byte	$8B
	.byte	$03
	.byte	$43
	.byte	$6C
	.byte	$6D
	.byte	$00
	.byte	$8B
	.byte	$10
	.byte	$6E
	.byte	$6F
	.byte	$70
	.byte	$71
	.byte	$72
	.byte	$6F
	.byte	$73
	.byte	$0F
	.byte	$8B
	.byte	$04
	.byte	$74
	.byte	$75
	.byte	$76
	.byte	$77
	.byte	$00
	.byte	$8B
	.byte	$11
	.byte	$78
	.byte	$79
	.byte	$7A
	.byte	$00
	.byte	$7B
	.byte	$0F
	.byte	$8B
	.byte	$04
	.byte	$7C
	.byte	$00
	.byte	$8B
	.byte	$18
	.byte	$7D
	.byte	$7E
	.byte	$8B
	.byte	$04
	.byte	$7F
	.byte	$00
	.byte	$8B
	.byte	$14
	.byte	$80
	.byte	$08
	.byte	$09
	.byte	$06
	.byte	$06
	.byte	$00
	.byte	$06
	.byte	$81
	.byte	$01
	.byte	$08
	.byte	$81
	.byte	$00
	.byte	$8B
	.byte	$6E
	.byte	$82
	.byte	$83
	.byte	$84
	.byte	$85
	.byte	$86
	.byte	$00
	.byte	$87
	.byte	$88
	.byte	$09
	.byte	$09
	.byte	$06
	.byte	$09
	.byte	$89
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$06
	.byte	$81
	.byte	$8A
	.byte	$05
	.byte	$03
	.byte	$07
	.byte	$06
	.byte	$00
	.byte	$8B
	.byte	$57
	.byte	$55
	.byte	$11
	.byte	$00
	.byte	$8B
	.byte	$05
	.byte	$55
	.byte	$55
	.byte	$00
	.byte	$8B
	.byte	$03
	.byte	$C0
	.byte	$30
	.byte	$65
	.byte	$55
	.byte	$00
	.byte	$8B
	.byte	$03
	.byte	$0C
	.byte	$88
	.byte	$A5
	.byte	$25
	.byte	$00
	.byte	$8B
	.byte	$10
	.byte	$00
	.byte	$8B
	.byte	$00
_PAL_TITLE:
	.byte	$37
	.byte	$30
	.byte	$17
	.byte	$0F
	.byte	$37
	.byte	$30
	.byte	$26
	.byte	$08
	.byte	$37
	.byte	$30
	.byte	$26
	.byte	$0F
	.byte	$37
	.byte	$30
	.byte	$28
	.byte	$0F
_BG_INTRO_TITLE:
	.byte	$4E,$69,$6E,$74,$65,$6E,$64,$6F,$21,$21,$0A,$45,$6E,$74,$65,$72
	.byte	$74,$61,$69,$6E,$6D,$65,$6E,$74,$20,$53,$79,$73,$74,$65,$6D,$21
	.byte	$21,$0A,$44,$65,$76,$65,$6C,$6F,$70,$65,$64,$20,$42,$79,$21,$21
	.byte	$2D,$20,$45,$6E,$74,$65,$72,$70,$72,$69,$73,$65,$20,$44,$65,$76
	.byte	$65,$6C,$6F,$70,$6D,$65,$6E,$74,$20,$2D,$21,$21,$0A,$44,$69,$73
	.byte	$74,$72,$69,$62,$75,$74,$65,$64,$20,$42,$79,$21,$21,$2D,$20,$45
	.byte	$6E,$74,$65,$72,$70,$72,$69,$73,$65,$20,$44,$69,$73,$74,$72,$69
	.byte	$62,$75,$74,$6F,$72,$20,$2D,$21,$21,$0A,$70,$72,$65,$73,$65,$6E
	.byte	$74,$21,$21,$0A,$2D,$20,$47,$61,$6D,$65,$20,$54,$49,$54,$4C,$45
	.byte	$20,$2D,$21,$21,$00
_PAL_INTRO_TITLE:
	.byte	$0F
	.byte	$20
	.byte	$20
	.byte	$20
_scIntro:
	.word	$0001
	.addr	_scIntroInitialized
	.addr	_scIntroAnimExec
	.addr	_scIntroInit
S0006:
	.byte	$50,$6C,$61,$79,$65,$72,$32,$00
S0005:
	.byte	$50,$6C,$61,$79,$65,$72,$31,$00

.segment	"BSS"

.segment	"ZEROPAGE"
_p:
	.res	2,$00
.segment	"BSS"
_SPRITES:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ hardware_vram_erase (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_vram_erase: near

.segment	"CODE"

;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; clear_vram_buffer();
;
	jmp     _clear_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_enable (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_enable: near

.segment	"CODE"

;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_disable (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_disable: near

.segment	"CODE"

;
; ppu_off();
;
	jmp     _ppu_off

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_write (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_write: near

.segment	"CODE"

;
; vram_adr(hardware.ppu.addr);
;
	lda     _hardware+8
	ldx     _hardware+8+1
	jsr     _vram_adr
;
; vram_unrle(hardware.ppu.data);
;
	lda     _hardware
	ldx     _hardware+1
	jmp     _vram_unrle

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_scroll_reset (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_scroll_reset: near

.segment	"CODE"

;
; set_scroll_x(0);
;
	ldx     #$00
	txa
	jmp     _set_scroll_x

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_draw_background: near

.segment	"CODE"

;
; pal_bg(hardware.ppu.background);
;
	lda     _hardware+2
	ldx     _hardware+2+1
	jmp     _pal_bg

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_palette_sprite (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_palette_sprite: near

.segment	"CODE"

;
; pal_spr(hardware.ppu.sprite_pal);
;
	lda     _hardware+6
	ldx     _hardware+6+1
	jmp     _pal_spr

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_palette_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_palette_background: near

.segment	"CODE"

;
; pal_bg(hardware.ppu.background_pal);
;
	lda     _hardware+4
	ldx     _hardware+4+1
	jmp     _pal_bg

.endproc

; ---------------------------------------------------------------
; void __near__ hardwate_ppu_wait_frame (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardwate_ppu_wait_frame: near

.segment	"CODE"

;
; ppu_wait_nmi();
;
	jmp     _ppu_wait_nmi

.endproc

; ---------------------------------------------------------------
; void __near__ harware_ppu_palette_bright (unsigned char level)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_harware_ppu_palette_bright: near

.segment	"CODE"

;
; void harware_ppu_palette_bright(unsigned char level) {
;
	jsr     pusha
;
; pal_bright(level);
;
	ldy     #$00
	lda     (sp),y
	jsr     _pal_bright
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ hardware_ppu_blank_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ppu_blank_screen: near

.segment	"CODE"

;
; vram_fill(0,1024);
;
	lda     #$00
	jsr     pusha
	ldx     #$04
	jmp     _vram_fill

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ hardware_ctrl1 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ctrl1: near

.segment	"CODE"

;
; return pad_poll(0);
;
	lda     #$00
	jmp     _pad_poll

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ hardware_ctrl1_prev (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ctrl1_prev: near

.segment	"CODE"

;
; return pad_state(0);
;
	lda     #$00
	jmp     _pad_state

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ hardware_ctrl2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ctrl2: near

.segment	"CODE"

;
; return pad_poll(1);
;
	lda     #$01
	jmp     _pad_poll

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ hardware_ctrl2_prev (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardware_ctrl2_prev: near

.segment	"CODE"

;
; return pad_state(1);
;
	lda     #$01
	jmp     _pad_state

.endproc

; ---------------------------------------------------------------
; void __near__ engine_handleInput (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_handleInput: near

.segment	"CODE"

;
; ActionProvider *provider = engine_actions[0];
;
	lda     _engine_actions+1
	sta     M0001+1
	lda     _engine_actions
	sta     M0001
;
; while(provider++ != NULL) {
;
	jmp     L000D
;
; if(engine.screen == provider->screen || provider->screen == S_ALL) {
;
L0002:	lda     _engine+19
	ldx     _engine+19+1
	jsr     pushax
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     tosicmp
	beq     L0008
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	cpx     #$01
	jne     L000D
	cmp     #$00
	jne     L000D
;
; Action *action = provider->actions[0];
;
L0008:	lda     M0001
	ldx     M0001+1
	clc
	adc     #$02
	bcc     L000B
	inx
L000B:	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     M0002+1
	dey
	lda     (ptr1),y
	sta     M0002
;
; while(action++ != NULL){
;
	jmp     L0016
;
; if((action->inputCode & hardware_ctrl1()) && !(action->inputCode & hardware_ctrl1_prev())) {
;
L000C:	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     pusha0
	jsr     _hardware_ctrl1
	jsr     tosandax
	stx     tmp1
	ora     tmp1
	beq     L0011
	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     pusha0
	jsr     _hardware_ctrl1_prev
	jsr     tosandax
	stx     tmp1
	ora     tmp1
	bne     L0011
;
; action->callback(&engine.player1);
;
	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	lda     #<(_engine)
	ldx     #>(_engine)
;
; } else if ((action->inputCode & hardware_ctrl2()) && !(action->inputCode & hardware_ctrl2_prev())) {
;
	jmp     L0024
L0011:	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     pusha0
	jsr     _hardware_ctrl2
	jsr     tosandax
	stx     tmp1
	ora     tmp1
	beq     L0016
	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     pusha0
	jsr     _hardware_ctrl2_prev
	jsr     tosandax
	stx     tmp1
	ora     tmp1
	bne     L0016
;
; action->callback(&engine.player2);
;
	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	lda     #<(_engine+9)
	ldx     #>(_engine+9)
L0024:	pha
	ldy     #$00
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; while(action++ != NULL){
;
L0016:	lda     M0002
	ldx     M0002+1
	cpx     #$00
	bne     L000F
	cmp     #$00
L000F:	jsr     boolne
	php
	lda     #$05
	clc
	adc     M0002
	sta     M0002
	bcc     L0010
	inc     M0002+1
L0010:	plp
	jne     L000C
;
; while(provider++ != NULL) {
;
L000D:	lda     M0001
	ldx     M0001+1
	cpx     #$00
	bne     L0005
	cmp     #$00
L0005:	jsr     boolne
	php
	lda     #$02
	clc
	adc     M0001
	sta     M0001
	bcc     L0006
	inc     M0001+1
L0006:	plp
	jne     L0002
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ engine_detectCollisions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_detectCollisions: near

.segment	"CODE"

;
; Screen *screen = engine_screens[0];
;
	lda     _engine_screens+1
	sta     M0001+1
	lda     _engine_screens
	sta     M0001
;
; if(!engine.player1.active && !engine.player2.active ||
;
	lda     _engine+4
	bne     L0003
	lda     _engine+13
	beq     L0025
;
; engine.player1.dead && engine.player2.dead ||
;
L0003:	lda     _engine+5
	beq     L0005
	lda     _engine+14
	bne     L0025
;
; engine.player1.collision != C_NONE && engine.player2.collision != C_NONE) return;
;
L0005:	lda     _engine+8
	cmp     #$10
	beq     L002D
	lda     _engine+17
	cmp     #$10
	beq     L002D
L0025:	rts
;
; engine.player1.collision = C_NONE;
;
L002D:	sta     _engine+8
;
; engine.player2.collision = C_NONE;
;
	sta     _engine+17
;
; while(screen++ != NULL) {
;
	jmp     L0010
;
; if(engine.screen == screen->id) {
;
L0008:	lda     _engine+19
	ldx     _engine+19+1
	jsr     pushax
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     tosicmp
	jne     L0010
;
; Graphic *graphic = screen->graphics;
;
	lda     M0001
	ldx     M0001+1
	clc
	adc     #$08
	bcc     L000E
	inx
L000E:	sta     M0002
	stx     M0002+1
;
; while(graphic++ != NULL) {
;
	jmp     L0016
;
; sprite_t *sprite = graphic->sprites;
;
L000F:	lda     M0002
	ldx     M0002+1
	clc
	adc     #$02
	bcc     L0014
	inx
L0014:	sta     M0003
	stx     M0003+1
;
; while(sprite++ != NULL) {
;
	jmp     L001C
;
; if(engine.player1.active)
;
L0015:	lda     _engine+4
	beq     L001A
;
; engine_detectCollisionWithPlayer(&engine.player1, sprite, graphic);
;
	jsr     decsp4
	lda     #<(_engine)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_engine)
	sta     (sp),y
	lda     M0003
	ldy     #$00
	sta     (sp),y
	iny
	lda     M0003+1
	sta     (sp),y
	lda     M0002
	ldx     M0002+1
	jsr     _engine_detectCollisionWithPlayer
;
; if(engine.player2.active)
;
L001A:	lda     _engine+13
	beq     L001B
;
; engine_detectCollisionWithPlayer(&engine.player2, sprite, graphic);
;
	jsr     decsp4
	lda     #<(_engine+9)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_engine+9)
	sta     (sp),y
	lda     M0003
	ldy     #$00
	sta     (sp),y
	iny
	lda     M0003+1
	sta     (sp),y
	lda     M0002
	ldx     M0002+1
	jsr     _engine_detectCollisionWithPlayer
;
; if((engine.player1.collision != C_NONE || !engine.player1.active) &&
;
L001B:	lda     _engine+8
	cmp     #$10
	bne     L0027
	lda     _engine+4
	bne     L001C
;
; (engine.player1.collision != C_NONE || !engine.player2.active))
;
L0027:	lda     _engine+8
	cmp     #$10
	bne     L002C
	lda     _engine+13
	bne     L001C
;
; return;
;
L002C:	rts
;
; while(sprite++ != NULL) {
;
L001C:	lda     M0003
	ldx     M0003+1
	cpx     #$00
	bne     L0018
	cmp     #$00
L0018:	jsr     boolne
	php
	lda     #$04
	clc
	adc     M0003
	sta     M0003
	bcc     L0019
	inc     M0003+1
L0019:	plp
	jne     L0015
;
; while(graphic++ != NULL) {
;
L0016:	lda     M0002
	ldx     M0002+1
	cpx     #$00
	bne     L0012
	cmp     #$00
L0012:	jsr     boolne
	php
	lda     #$02
	clc
	adc     M0002
	sta     M0002
	bcc     L0013
	inc     M0002+1
L0013:	plp
	jne     L000F
;
; while(screen++ != NULL) {
;
L0010:	lda     M0001
	ldx     M0001+1
	cpx     #$00
	bne     L000B
	cmp     #$00
L000B:	jsr     boolne
	php
	lda     #$08
	clc
	adc     M0001
	sta     M0001
	bcc     L000C
	inc     M0001+1
L000C:	plp
	jne     L0008
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00
M0003:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ engine_detectCollisionWithPlayer (struct $anon-struct-0008 *player, struct sprite *sprite, struct $anon-struct-0009 *graphic)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_detectCollisionWithPlayer: near

.segment	"CODE"

;
; void engine_detectCollisionWithPlayer(Player *player, sprite_t *sprite, Graphic *graphic) {
;
	jsr     pushax
;
; if(player->dead) return;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	bne     L0003
;
; if(engine_detectCollision(&player->position, sprite)) {
;
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$06
	bcc     L0004
	inx
L0004:	jsr     pushax
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _engine_detectCollision
	tax
	beq     L0003
;
; player->collision = C_LEVEL;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$15
	ldy     #$08
	sta     (ptr1),y
;
; (* graphic->collide)(sprite, player);
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	ldy     #$07
	jsr     pushwysp
	ldy     #$09
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	pha
	ldy     #$02
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; }
;
L0003:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ engine_start (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_start: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; set_vram_buffer(); // do at least once
;
	jsr     _set_vram_buffer
;
; oam_clear();
;
	jsr     _oam_clear
;
; clear_vram_buffer(); // reset every frame
;
	jsr     _clear_vram_buffer
;
; pal_bright(4);
;
	lda     #$04
	jsr     _pal_bright
;
; engine_frame_update();
;
L0002:	jsr     _engine_frame_update
;
; hardwate_ppu_wait_frame();
;
	jsr     _hardwate_ppu_wait_frame
;
; while(1) {
;
	jmp     L0002

.endproc

; ---------------------------------------------------------------
; void __near__ engine_frame_update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_frame_update: near

.segment	"CODE"

;
; if(0x00 == *engine_screens[engine.screenIndex]->initialized) {
;
	jsr     push0
	lda     _engine+21
	asl     a
	bcc     L0006
	ldx     #$01
	clc
L0006:	adc     #<(_engine_screens)
	sta     ptr1
	txa
	adc     #>(_engine_screens)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$03
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     tosicmp0
	bne     L0002
;
; engine_screens[engine.screenIndex]->init();
;
	ldx     #$00
	lda     _engine+21
	asl     a
	bcc     L0007
	inx
	clc
L0007:	adc     #<(_engine_screens)
	sta     ptr1
	txa
	adc     #>(_engine_screens)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$07
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	pha
	ldy     #$00
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; engine_screens[engine.screenIndex]->update();
;
L0002:	ldx     #$00
	lda     _engine+21
	asl     a
	bcc     L0008
	inx
	clc
L0008:	adc     #<(_engine_screens)
	sta     ptr1
	txa
	adc     #>(_engine_screens)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$05
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	pha
	ldy     #$00
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ engine_detectCollision (struct $anon-struct-0005 *position, struct sprite *sprite)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_engine_detectCollision: near

.segment	"CODE"

;
; bool engine_detectCollision(Position *position, sprite_t *sprite) {
;
	jsr     pushax
;
; return false;
;
	ldx     #$00
	txa
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ scIntroDisplayItem (unsigned int y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_scIntroDisplayItem: near

.segment	"CODE"

;
; void scIntroDisplayItem(uint16_t y) {
;
	jsr     pushax
;
; i=index; o=0;
;
	lda     _index
	sta     _i
	lda     #$00
	sta     _o
;
; p[o] = (uint8_t) BG_INTRO_TITLE[i];
;
L0002:	lda     #<(M0001)
	ldx     #>(M0001)
	clc
	adc     _o
	bcc     L0005
	inx
L0005:	sta     ptr1
	stx     ptr1+1
	ldy     _i
	lda     _BG_INTRO_TITLE,y
	ldy     #$00
	sta     (ptr1),y
;
; i++; o++;
;
	inc     _i
	inc     _o
;
; } while(!(BG_INTRO_TITLE[i]=='!' && BG_INTRO_TITLE[i+1]=='!'));
;
	ldy     _i
	lda     _BG_INTRO_TITLE,y
	cmp     #$21
	bne     L0013
	ldx     #$00
	lda     _i
	clc
	adc     #$01
	bcc     L0009
	inx
L0009:	sta     ptr1
	txa
	clc
	adc     #>(_BG_INTRO_TITLE)
	sta     ptr1+1
	ldy     #<(_BG_INTRO_TITLE)
	lda     (ptr1),y
	cmp     #$21
	beq     L0014
L0013:	lda     #$00
	jmp     L000B
L0014:	lda     #$01
L000B:	jsr     bnega
	bne     L0002
;
; index = i+2;
;
	lda     _i
	clc
	adc     #$02
	sta     _index
;
; o = o>>1;
;
	lda     _o
	lsr     a
	sta     _o
;
; if(o<16){
;
	cmp     #$10
	bcs     L000D
;
; j=0;
;
	ldx     #$00
	stx     _j
;
; while((j+o)<16) ++j;
;
	jmp     L0016
L0015:	inc     _j
	ldx     #$00
L0016:	lda     _j
	clc
	adc     _o
	bcc     L0012
	inx
L0012:	cmp     #$10
	txa
	sbc     #$00
	bvc     L0011
	eor     #$80
L0011:	bmi     L0015
;
; y += j;
;
	ldx     #$00
	lda     _j
	jsr     addeq0sp
;
; hardware.ppu.addr = NAMETABLE_A | y;
;
L000D:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     _hardware+8
	txa
	ora     #$20
	sta     _hardware+8+1
;
; hardware.ppu.data = p;
;
	lda     #>(M0001)
	sta     _hardware+1
	lda     #<(M0001)
	sta     _hardware
;
; multi_vram_buffer_horz(hardware.ppu.data, sizeof(p), hardware.ppu.addr);
;
	jsr     decsp3
	lda     _hardware
	iny
	sta     (sp),y
	iny
	lda     _hardware+1
	sta     (sp),y
	lda     #$63
	ldy     #$00
	sta     (sp),y
	lda     _hardware+8
	ldx     _hardware+8+1
	jsr     _multi_vram_buffer_horz
;
; free(p);
;
	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     _free
;
; }
;
	jmp     incsp2

.segment	"BSS"

M0001:
	.res	99,$00

.endproc

; ---------------------------------------------------------------
; void __near__ scIntroInit (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_scIntroInit: near

.segment	"CODE"

;
; hardware_ppu_disable();
;
	jsr     _hardware_ppu_disable
;
; hardware_ppu_scroll_reset();
;
	jsr     _hardware_ppu_scroll_reset
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; hardware_ppu_blank_screen();
;
	jsr     _hardware_ppu_blank_screen
;
; engine.screen = S_TITLE;
;
	ldx     #$00
	lda     #$01
	sta     _engine+19
	stx     _engine+19+1
;
; hardware.ppu.sprite_pal = PAL_INTRO_TITLE;
;
	lda     #>(_PAL_INTRO_TITLE)
	sta     _hardware+6+1
	lda     #<(_PAL_INTRO_TITLE)
	sta     _hardware+6
;
; hardware_ppu_palette_sprite();
;
	jsr     _hardware_ppu_palette_sprite
;
; hardware.ppu.background_pal = PAL_INTRO_TITLE;
;
	lda     #>(_PAL_INTRO_TITLE)
	sta     _hardware+4+1
	lda     #<(_PAL_INTRO_TITLE)
	sta     _hardware+4
;
; hardware_ppu_palette_background();
;
	jsr     _hardware_ppu_palette_background
;
; scIntroInitialized = true;
;
	lda     #$01
	sta     _scIntroInitialized
;
; hardware_ppu_enable();
;
	jmp     _hardware_ppu_enable

.endproc

; ---------------------------------------------------------------
; void __near__ scIntroAnimExec (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_scIntroAnimExec: near

.segment	"CODE"

;
; index = 0x00;
;
	lda     #$00
	sta     _index
;
; scIntroDisplayItem( NUM_COLS * 2 + i);
;
	tax
	lda     _i
	clc
	adc     #$40
	bcc     L0002
	inx
L0002:	jsr     _scIntroDisplayItem
;
; scIntroDisplayItem( NUM_COLS * 6);
;
	ldx     #$00
	lda     #$C0
	jsr     _scIntroDisplayItem
;
; scIntroDisplayItem( NUM_COLS * 10);
;
	ldx     #$01
	lda     #$40
	jsr     _scIntroDisplayItem
;
; scIntroDisplayItem( NUM_COLS * 11);
;
	ldx     #$01
	lda     #$60
	jsr     _scIntroDisplayItem
;
; scIntroDisplayItem( NUM_COLS * 15);
;
	ldx     #$01
	lda     #$E0
	jsr     _scIntroDisplayItem
;
; scIntroDisplayItem( NUM_COLS * 16);
;
	ldx     #$02
	lda     #$00
	jsr     _scIntroDisplayItem
;
; ++i;
;
	inc     _i
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; engine_screens[0] = (Screen*) &scIntro;
;
	lda     #>(_scIntro)
	sta     _engine_screens+1
	lda     #<(_scIntro)
	sta     _engine_screens
;
; engine.screen = S_TITLE;
;
	ldx     #$00
	lda     #$01
	sta     _engine+19
	stx     _engine+19+1
;
; engine.screenIndex = 0;
;
	stx     _engine+21
;
; engine_start();
;
	jmp     _engine_start

.endproc

